# Search Race Guard

Демонстрационное приложение на Next.js (App Router), показывающее как собрать устойчивую поисковую форму с дебаунсом, отменой запросов и синхронизацией URL.

## Стек

- Next.js 15 (App Router)
- React 19 (клиентские компоненты поверх серверного рендера)
- TypeScript в режиме `strict`
- CSS Modules

## Что умеет

- Дебаунс ввода на 300 мс: сокращает шум запросов без потери отзывчивости
- Отмена запросов + защита от гонок (AbortController и идентификаторы последнего запроса)
- Синхронизация с параметром `?q=` и корректная работа истории браузера
- Полный набор UI-состояний (`idle`, `loading`, `success`, `error`, `no-results`) с доступными озвучками
- Скелетоны загрузки, сохранение фокуса и плавные подсказки без скачков макета

## Быстрый старт

```bash
pnpm install
pnpm dev

# проверка прод-сборки
pnpm build
pnpm start
```

Альтернативы:

```bash
npm install
npm run dev

# или
yarn install
yarn dev
```

Откройте http://localhost:3000 и начните вводить запрос.

## Архитектура и ответственность

- `app/` — точки входа App Router (`layout.tsx`, `page.tsx`) и клиентский контейнер `SearchClient`. Страница читает `searchParams` на сервере, а состояние и запросы живут в клиентском компоненте.
- `components/` — презентационные блоки (`SearchInput`, `ResultsList`, `ResultItem`) с локальными стилями CSS Modules.
- `hooks/` — поведенческие примитивы:
  - `useDebouncedValue` — безопасный для Strict Mode дебаунс через `setTimeout`.
  - `useCancelableFetch` — единая точка управления AbortController и фильтрации устаревших ответов.
- `lib/searchApi.ts` — обёртка над `fetch` с рантайм-проверкой структуры ответа.

`SearchClient` разделяет зоны ответственности:

1. Контролируемое поле ввода и мгновенный сброс состояния при пустой строке.
2. Актуализация URL через `router.replace(..., { scroll: false })` с защитой от лишних навигаций.
3. Асинхронные запросы через `useCancelableFetch`; дебаунс даёт паузу, а истории браузера и прямые переходы синхронизируются без дублей.
4. Управление статусами + передача данных в презентационные компоненты.

## Мок-API

- `GET /api/search`
- Параметры: `q` (строка, обязательный), `limit` (число, опционально, по умолчанию 10)
- Поведение: искусственная задержка 500 мс, 10% шанс ответа `503` с `{ message }`, поиск по статическому датасету с обрезкой по `limit`.

Формат ответа:

```ts
interface SearchResult {
  id: string;
  title: string;
  snippet: string;
}

interface SearchResponse {
  results: SearchResult[];
}
```

## Доступность и производительность

- `aria-live="polite"` + привязка к полю — статусы и ошибки озвучиваются сразу.
- Клавиатура в приоритете: явная метка `<label>`, `:focus-visible`, кнопка очистки возвращает фокус в поле.
- Скелетоны и сохранение предыдущих результатов убирают скачки интерфейса.
- Все асинхронные операции отменяются при новом вводе или размонтировании, что экономит ресурсы.

## Ограничения и рост

- Данные статичны; для продакшена пригодятся пагинация, инкрементальный поиск или стриминг.
- Нет аналитики, авторизации и i18n — их можно добавить отдельными слоями.
- Ошибки лишь отображаются пользователю; в бою стоит отправлять их в наблюдаемость и кешировать офлайн.
- Поиск по одному индексу; масштабирование потребует шардирования и батчинга на стороне `useCancelableFetch` или серверных действий.

## Почему Next.js

App Router сочетает быструю первую отрисовку (сервер) и удобные клиентские хуки для состояния URL. Встроенные Route Handlers, стриминг и разделение компонентов позволяют собрать рабочий поисковый сценарий без дополнительных библиотек и сложной настройки.

## TODO

- Настроить ESLint для статического анализа
- Подключить Prettier для форматирования
- Добавить автоматические тесты (юнит/интеграция)

## Лицензия

MIT
